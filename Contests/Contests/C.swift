//C. Алиса и тайный дневник
//Ограничение времени    1 секунда
//Ограничение памяти    64Mb
//Ввод    стандартный ввод
//Вывод    стандартный вывод
//Алиса и Боб живут вместе уже много лет. Внезапно выяснилось, что Боб совершенно не помнит дату, когда они поженились. Данный факт очень возмутил Алису. Чтобы Боб лучше запомнил эту памятную дату, она придумала игру со следующими правилами:
//Алиса в тайном дневнике выписала все-все-все памятные даты, расположив их в хронологическом порядке. В один день произошло ровно одно памятное событие. Алиса ни под каким предлогом не показывает тайный дневник Бобу.
//Оказалось, что дата, когда они поженились, расположилась ровно в середине списка. Причем список имеет нечетную длину. Обо всем этом Алиса сообщила Бобу.
//Каждый день Боб оставляет на столе конверт, где пишет ровно одну дату - предполагаемую дату, когда они поженились. И уходит на работу.
//Алиса забирает конверт, смотрит на дату, открывает свой тайный дневник и считает количество событий, которые произошли до этой даты включительно, а затем пишет Бобу ответную записку, где указывает это число.
//Пункты 3-4 повторяются, пока Боб не определит точную дату памятного события.
//Боб очень любит Алису и хочет как можно скорее определить дату, когда они поженились. Кроме того, Алиса установила Бобу предельное количество попыток
//N
//, за которые Боб должен угадать памятную дату. Боб просит вас написать компьютерную программу, которая поможет ему в этом.
//
//Формат ввода
//Эта задача немного необычна: в ней вам предстоит реализовать интерактивное взаимодействие с тестирующей системой. Это означает, что вы можете делать запросы и получать ответы в online-режиме.
//Для чтения ответов тестирующей системы программа должна использовать стандартный ввод.
//В первой строке входных данных будет содержаться целое число - предельное количество попыток угадать памятную дату.
//Известно, что все памятные даты Алисы находятся в промежутке и что существует алгоритм, позволяющий угадать дату за требуемое количество попыток. Все даты заданы в формате «dd.mm.yyyy» (без кавычек). В таком же формате их необходимо задавать в запросах к тестирующей системе.
//В следующих строках на вход вашей программе будут подаваться строки, содержащие информацию об ответе Алисы.
//i
//-я из этих строк является ответом системы на ваш
//i
//-й запрос.
//Ваша программа должна выводить запросы к тестирующей системе и обрабатывать ответы от нее. После вывода каждой строки программа должна выполнить операцию flush. Ответ на запрос программа сможет прочесть из стандартного ввода.
//Доступные ответы системы:
//«? K» (без кавычек) - ответ тестирующей системы, означающий, что до посланной проверяемой даты произошло
//K
// памятных событий
//«!» (без кавычек) - ответ тестирующей системы, означающий, что превышено количество попыток
//N
// угадать памятную дату.
//В шаблоне решения реализовано считывание конфигурации тестирующей системы, посылка запроса. См. результат функции print[_answer](date) и ask(date) .
//
//Формат вывода
//Для запросов к тестирующей системе программа должна использовать стандартный вывод.
//
//Доступные запросы системы:
//
//«? M» (без кавычек) - проверить, является ли дата - памятной датой.
//«! M» (без кавычек) - указать, что дата является памятной. После того, как ваша программа вывела данную команду, следует завершить работу.

//import Foundation
//
//func ask() {
//    let maxN = Int(readLine()!) ?? 0
//    print("? 31.12.2020")
//    fflush(stdout)
//    let firstResponce = readLine()!.split(separator: " ")
//    if firstResponce[0] == "!" {
//        return
//    }
//    let amount = Int(firstResponce[1]) ?? 0
//    let answer = amount / 2 + 1
//    
//    let dateFormatter = DateFormatter()
//    dateFormatter.dateFormat = "dd.MM.yyyy"
//    var right = dateFormatter.date(from: "31.12.2020")
//    var left = dateFormatter.date(from: "01.01.1970")
//    
//    for _ in 1..<maxN {
//        let middle = left!.timeIntervalSince1970 + right!.timeIntervalSince(left!) / 2
//        let middleDate = Date(timeIntervalSince1970: middle)
//        print("? \(dateFormatter.string(from: middleDate))")
//        fflush(stdout)
//        let responce = readLine()!.split(separator: " ")
//        if responce[0] == "!" {
//            return
//        }
//        if Int(responce[1])! < answer {
//            left = middleDate
//        } else if Int(responce[1])! > answer {
//            right = middleDate
//        } else {
//            print("! \(dateFormatter.string(from: middleDate))")
//        }
//    }
//}
//
//ask()
